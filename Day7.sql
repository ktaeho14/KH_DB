--제약조건--
--CHECK 제약조건--
--컬럼에 값을 기록할 때 지정한값 이외에는 값이
--기록되지 않도록 범위를 제한하는 조건
--CHECK (컬럼명 비교연산자 값)
--EX) CHECK(GENDER IN('F','M') )

CREATE TABLE USER_CHECK(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(15),
    GENDER CHAR(3) CHECK(GENDER IN ('남','여') )
);
SELECT *
FROM USER_CHECK;

INSERT INTO USER_CHECK
VALUES(1,'USER01','PASS01','홍길동','남');

--ORA-12899: value too large for column "KH"."USER_CHECK"."GENDER" (actual: 6, maximum: 3)
INSERT INTO USER_CHECK
VALUES(2,'USER02','PASS02','고길동','남자');

--ORA-02290: check constraint (KH.SYS_C007055) violated
INSERT INTO USER_CHECK
VALUES(2,'USER02','PASS02','고길동','M');


--CHECK 제약조건에 부등호
CREATE TABLE TEST_CHECK2(
    TEST_DATA NUMBER,
    CONSTRAINT CK_TEST_DATA CHECK(TEST_DATA>0)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='TEST_CHECK2' OR TABLE_NAME = 'USER_UNIQUE2';

INSERT INTO TEST_CHECK2 VALUES(10);

--ORA-02290: check constraint (KH.CK_TEST_DATA) violated
INSERT INTO TEST_CHECK2 VALUES(-10);

CREATE TABLE TEST_CHECK3(
    C_NAME VARCHAR2(15),
    C_PRICE NUMBER CONSTRAINT CK_TESTCHECK3_PRICE CHECK (C_PRICE BETWEEN 1 AND 99999),
    C_DATE DATE,
    C_QUAL CHAR(1),
    CONSTRAINT CK_TESTCHECK3_DATE CHECK(C_DATE >= TO_DATE('2010/01/01', 'YYYY//MM/DD') ),
    CONSTRAINT CK_TESTCHECK3_QUAL CHECK(C_QUAL >= 'A' AND C_QUAL<='D')
);


--제약조건 여러개 설정하기
CREATE TABLE TEST_DUAL_CONS(
    TEST_NO NUMBER NOT NULL UNIQUE,
    TEST_NO2 NUMBER NOT NULL

);

SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'TEST_DUAL_CONS';

--PRIMARY KEY 제약조건--
--'기본키 제약조건'
--테이블 내의 한 행에서 그 행을 식별하기 위한 고유값을 가지는 컬럼에
--NOT NULL, UNIQUE 제약조건을 함께 걸어주는 제약조건.
-- 테이블 전체에 대한 각 데이터의 식별자 역할을 수행
--NOT NULL, UNIQUE 가들어가있으며 테이블마다 1개의 기본키제약조건이 들어가며 컬럼이 1개일수도 2개일수도있다.

CREATE TABLE USER_PK_TABLE(
    USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY, --컬럼 레벨 제약조건 설정
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(15) NOT NULL,
    GENDER VARCHAR2(3) CHECK(GENDER IN('남','여'))

);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_PK_TABLE';


INSERT INTO USER_PK_TABLE
VALUES (1,'USER01','PASS01','홍길동','남');

INSERT INTO USER_PK_TABLE
VALUES(2,'USER02','PASS02','고길동','여');

--ORA-00001: unique constraint (KH.PK_USER_NO) violated
--PRIMARY KEY 제약조건이 걸려있는 USER_NO컬럼제약조건에 걸린다.(UNIQUE 중복이 걸린다)
INSERT INTO USER_PK_TABLE
VALUES(1,'USER03','PASS03','최길동','남');

--ORA-01400: cannot insert NULL into ("KH"."USER_PK_TABLE"."USER_NO")
--PRIMARY KEY 제약 조건이 걸려있는 USER_NO컬럼제약조건에 걸린다.(NOT NULL, NULL을 넣을수없음)
INSERT INTO USER_PK_TABLE
VALUES(NULL,'USER03','PASS03','최길동','남');


--기본키 제약조건을 여러 컬럼에 적용하기
CREATE TABLE USER_PK_TABLE2(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(15) NOT NULL,
    GENDER VARCHAR2(3) CHECK(GENDER IN('M','F')),
    CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO,USER_ID)
);

--1, USER01 => 성공
--2, USER02 => 성공
--1, USER03 => 성공
--2, USER01 => 실패!! => USER_ID가 UNIQUE


--실습 1.
--MEMBER 테이블을 생성하여
--사용자 정보를 받을 수 있는 테이블 객체를 만들되,
--회원 번호는 NUMBER형태로 기본키 설정하고,
--회원 아이디는 중복 불가에 필수 입력 사항으로,
--회원 비밀번호는 필수 입력 사항,
--회원 이름, 성별('M','F'),
--회원 연락처, 회원 생년월일 정보를
--받을 수 있는 컬럼을 가진 테이블을 생성하시오.
--단, 각 컬럼의 길이는 직접 판단하고,
--위에 생성된 테이블 기준으로
--회원 정보를 최소 5개 이상 삽입하여 확인하시오.

DROP TABLE MEMBER; --테이블 삭제, DROP은 객체를 삭제하는 명령어

CREATE TABLE MEMBER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(30) UNIQUE NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(15),
    GENDER CHAR(3) CHECK(GENDER IN ('M','F')),
    USER_PHONE VARCHAR2(20),
    USER_BIRTH DATE
);

COMMENT ON COLUMN MEMBER.USER_NO IS '회원번호';

INSERT INTO MEMBER
VALUES(1,'USER01','PASS01','김수호','M','01011111111','1995/12/18');

INSERT INTO MEMBER
VALUES(2,'USER02','PASS02','이수호','F','01022222222','1995/12/12');

INSERT INTO MEMBER
VALUES(3,'USER03','PASS03','최수호','M','01033333333','1995/11/15');

INSERT INTO MEMBER
VALUES(4,'USER04','PASS04','유수호','M','01044444444','1991/10/18');

INSERT INTO MEMBER
VALUES(5,'USER05','PASS05','권수호','M','01055555555','2005/03/18');

SELECT *
FROM MEMBER
ORDER BY USER_ID ASC;


--FOREIGN KEY--
--외래키, 외부키, 참조키
--다른 테이블의 컬럼값을 참조(REFERENCE)하여
--참조하는 테이블의 값만을 허용한다.
--관계가 형성된다

--컬럼 레벨
--컬럼명 자료형(길이) [CONSTRAINT 제약조건명] REFERENCES 참조할테이블명 [ (참조할컬럼명) ] [삭제 옵션]

--테이블레벨
--[CONSTRAINT 제약조건명] FOREIGN KEY (적용할 컬럼명) REFERENCES 참조할테이블명[ (참조할 컬럼명) ] [삭제 옵션]

--참조할 컬럼명을 생략할 경우
--대상 테이블의 기본키를 참조한다.
--또한, 참조하고자 하는 컬럼은 반드시 PRIMARY KEY이거나 UNIQUE 제약조건이 걸려 있어야 한다.

CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR(30) NOT NULL

);

INSERT INTO USER_GRADE VALUES(1,'일반회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;



CREATE TABLE USER_FOREIGN_KEY(
    NO NUMBER PRIMARY KEY,
    ID VARCHAR2(20),
    PWD VARCHAR2(30),
    NAME VARCHAR2(15),
    GENDER CHAR(1) CHECK(GENDER IN('M','F')),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE)
    REFERENCES USER_GRADE(GRADE_CODE)


);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','이창진','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'abc','abc1','user1','M',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','654','김길동','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'def','fed2','user2','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'qwe','ewq','user3','M',1);

SELECT * FROM USER_FOREIGN_KEY;


SELECT *
FROM USER_FOREIGN_KEY JOIN USER_GRADE USING(GRADE_CODE);

--ORA-02291: integrity constraint (KH.FK_GRADE_CODE) violated - parent key not found
INSERT INTO USER_FOREIGN_KEY VALUES(6, 'zxc','asd','user4','F',10);

--삭제 옵션

--ORA-02292: integrity constraint (KH.FK_GRADE_CODE) violated - child record found
DELETE FROM USER_GRADE
WHERE GRADE_CODE = 4;


--1. 부모 컬럼을 삭제할 때 자식을 NULL로 변경하기
-- ON DELETE SET NULL

--2. 부모 컬럼을 삭제할 때 관련된 자식도 함께 삭제
-- ON DELETE CASCADE

--ORA-02449: unique/primary keys in table referenced by foreign keys
DROP TABLE USER_GRADE;

DROP TABLE USER_FOREIGN_KEY;

CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR(30) NOT NULL

);

INSERT INTO USER_GRADE VALUES(1,'일반회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;

--1. USER_FOREIGN_KEY + ON DELETE SET NULL

CREATE TABLE USER_FOREIGN_KEY(
    NO NUMBER PRIMARY KEY,
    ID VARCHAR2(20),
    PWD VARCHAR2(30),
    NAME VARCHAR2(15),
    GENDER CHAR(1) CHECK(GENDER IN('M','F')),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE)
    REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','이창진','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'abc','abc1','user1','M',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','654','김길동','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'def','fed2','user2','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'qwe','ewq','user3','M',1);

SELECT * FROM USER_FOREIGN_KEY;

COMMIT;

DELETE FROM USER_GRADE WHERE GRADE_CODE = 1;

SELECT * FROM USER_FOREIGN_KEY;


ROLLBACK;

--2. USER_FOREIGN_KEY + ON DELETE CASCADE
DROP TABLE USER_FOREIGN_KEY;

CREATE TABLE USER_FOREIGN_KEY(
    NO NUMBER PRIMARY KEY,
    ID VARCHAR2(20),
    PWD VARCHAR2(30),
    NAME VARCHAR2(15),
    GENDER CHAR(1) CHECK(GENDER IN('M','F')),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE)
    REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE


);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','이창진','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'abc','abc1','user1','M',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','654','김길동','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'def','fed2','user2','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'qwe','ewq','user3','M',1);

SELECT * FROM USER_FOREIGN_KEY;

COMMIT;

DELETE FROM USER_GRADE WHERE GRADE_CODE = 4;

SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGN_KEY;

ROLLBACK;


--SUBQUERY를 활용한 테이블 만들기--
--컬럼명, 데이터 타입, 값, NOT NULL은 복사가 가능하다.
--하지만 다른 제약조건은 복사되지 않는다.

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEE';

--AS를 넣어줌으로 복제를 하였다(서브쿼리)
CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE;


SELECT * FROM EMPLOYEE_COPY;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEE_COPY';


-- 테이블의 형식만 복사하기
--값은 제외
CREATE TABLE EMPLOYEE_COPY2
AS SELECT * FROM EMPLOYEE WHERE 1=2;

-- 각 컬럼에 값을 기록하지 않을 경우 기본값 설정하기
-- DEFAULT
CREATE TABLE DEFAULT_TABLE(
    COL1 VARCHAR2(30) DEFAULT '없음',
    COL2 DATE DEFAULT SYSDATE
);

INSERT INTO DEFAULT_TABLE VALUES(DEFAULT, DEFAULT);

SELECT * FROM DEFAULT_TABLE;



--ALTER : 수정하겠다!
--CREATE : 만들겠다!
--DELETE : 지우겠다!


--오늘의 진도 제약 조건을 테이블 생성 후에 추가하는 DDL까지
--ALTER


--[사용형식]
--ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
--ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명),REFERENCES 테이블명(컬럼명)
--ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
--ALTER TABLE 테이블명 ADD CHECK(조건식)
--ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

-- EMPLOYEE 테이블에서
--   DEPT_CODE에 외래키 제약 조건 추가
--   참조할 컬럼은 DEPARTMENT.DEPT_ID
--   JOB_CODE에 외래키 제약 조건 추가
--   참조할 컬럼은 JOB.JOB_CODE
--   SAL_LEVEL에 외래키 제약 조건 추가
--   참조할 컬럼은 SAL_GRADE.SAL_LEVEL
--   ENT_YN 컬럼에 CHECK 제악조건 추가 ('Y', 'N') 대소문자 구분
--   SALARY 컬럼에 CHECK 제약조건 추가 (무조건 양수 기입)
--   EMP_NO 컬럼에 UNIQUE 제약 조건 추가
-- DEPARTMENT 테이블에서
--   LOCATION_ID에 외래키 제약조건 추가
--   LOCATION 테이블의 기본키 컬럼
-- LOCATION 테이블에서 NATIONAL_CODE 외래키 제약 조건 추가
--   NATIONAL 테이블의 기본키 컬럼
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (DEPT_CODE)
REFERENCES DEPARTMENT;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE)
REFERENCES JOB;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL)
REFERENCES SAL_GRADE(SAL_LEVEL);

ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN('Y','N'));

ALTER TABLE EMPLOYEE ADD CHECK(SALARY>0);

ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

--제약조건을 중간에 변경할 경우
--이미 존재하는 값의 조건 부합 여부도 확인해야한다.
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(MANAGER_ID)
REFERENCES EMPLOYEE;

ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID)
REFERENCES LOCATION;

ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE)
REFERENCES NATIONAL; 

SELECT C1.TABLE_NAME "테이블 명", C1.CONSTRAINT_NAME "제약조건 명",
        CONSTRAINT_TYPE "타입", COLUMN_NAME "컬럼명", SEARCH_CONDITION "조건내용"
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON (C1.TABLE_NAME = C2.TABLE_NAME AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN ('EMPLOYEE','DEPARTMENT','LOCATION');





